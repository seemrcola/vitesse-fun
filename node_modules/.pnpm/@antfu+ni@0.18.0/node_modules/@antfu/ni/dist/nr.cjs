'use strict';

const runner = require('./chunks/runner.cjs');
const fs = require('fs');
const require$$0 = require('path');
const os = require('os');
require('readline');
require('events');
require('node:buffer');
require('node:path');
require('node:child_process');
require('node:process');
require('child_process');
require('node:url');
require('node:os');
require('assert');
require('buffer');
require('stream');
require('util');
require('node:fs');
require('tty');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

let storage;
const storageDir = require$$0.resolve(os.tmpdir(), "antfu-ni");
const storagePath = require$$0.resolve(storageDir, "_storage.json");
async function load(fn) {
  if (!storage) {
    storage = fs.existsSync(storagePath) ? JSON.parse(await fs.promises.readFile(storagePath, "utf-8") || "{}") || {} : {};
  }
  if (fn) {
    if (await fn(storage))
      await dump();
  }
  return storage;
}
async function dump() {
  if (storage) {
    if (!fs.existsSync(storageDir))
      await fs.promises.mkdir(storageDir, { recursive: true });
    await fs.promises.writeFile(storagePath, JSON.stringify(storage), "utf-8");
  }
}

function getPackageJSON(cwd = process.cwd()) {
  const path = require$$0.resolve(cwd, "package.json");
  if (fs__default.existsSync(path)) {
    try {
      const raw = fs__default.readFileSync(path, "utf-8");
      const data = JSON.parse(raw);
      return data;
    } catch (e) {
      console.warn("Failed to parse package.json");
      process.exit(0);
    }
  }
}

runner.runCli(async (agent, args, ctx) => {
  const storage = await load();
  if (args[0] === "-") {
    if (!storage.lastRunCommand) {
      console.error("No last command found");
      process.exit(1);
    }
    args[0] = storage.lastRunCommand;
  }
  if (args.length === 0) {
    let limitText = function(text, maxWidth) {
      if (text.length <= maxWidth)
        return text;
      return `${text.slice(0, maxWidth)}${$.dim("\u2026")}`;
    };
    const pkg = getPackageJSON(ctx?.cwd);
    const scripts = pkg.scripts || {};
    const scriptsInfo = pkg["scripts-info"] || {};
    const names = Object.entries(scripts);
    if (!names.length)
      return;
    const terminalColumns = process.stdout?.columns || 80;
    const choices = names.filter((i) => !i[0].startsWith("?")).map(([value, cmd]) => ({
      title: value,
      value,
      description: limitText(scriptsInfo[value] || scripts[`?${value}`] || cmd, terminalColumns - 15)
    }));
    if (storage.lastRunCommand) {
      const last = choices.find((i) => i.value === storage.lastRunCommand);
      if (last)
        choices.unshift(last);
    }
    try {
      const { fn } = await runner.prompts({
        name: "fn",
        message: "script to run",
        type: "autocomplete",
        choices
      });
      if (!fn)
        return;
      args.push(fn);
    } catch (e) {
      process.exit(1);
    }
  }
  if (storage.lastRunCommand !== args[0]) {
    storage.lastRunCommand = args[0];
    dump();
  }
  return runner.parseNr(agent, args);
});
